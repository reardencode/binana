| BIN-2024-0003 | `CHECKSIGFROMSTACK`
| :------------ | :-------
| Revision      | 001 (2024-01-27)
| Author        | Brandon Black `<freedom@reardencode.com>`
| |
| Layer         | Consensus (soft fork)
| Status        | Draft
| License       | BSD-3-CLAUSE
| |
| Discussion    | https://delvingbitcoin.org/t/lnhance-bips-and-implementation/376/9
| Aliases       | [BIPs PR#1535](https://github.com/bitcoin/bips/pull/1535)

## Abstract

This BIP describes two new opcode for the purpose of checking cryptographic
signatures in bitcoin scripts against data other than bitcoin transactions.

## Summary

We propose replacing `OP_NOP5` (0xb4) in bitcoin script with
`OP_CHECKSIGFROMSTACKVERIFY`. When verifying taproot script spends having
leaf version 0xc0 (as defined in [BIP 342]), we propose `OP_CHECKSIGFROMSTACK`
to replace `OP_SUCCESS204` (0xcc).

`OP_CHECKSIGFROMSTACK` and `OP_CHECKSIGFROMSTACKVERIFY`
have semantics similar to `OP_CHECKSIG` and
`OP_CHECKSIGVERIFY` respectively, as specified below.

Only 32-byte keys are constrained. Similar to [BIP 341] unknown key types, for
other key lengths no signature verification is performed.

## Specification

* If fewer than 3 elements are on the stack, the script MUST fail and terminate immediately.
* If the top element of the stack is a 1-byte CScriptNum from 1 to 16 (inclusive):
    * `n_extra` is equal to the top element of the stack decoded as CScriptNum.
    * If fewer than `n_extra + 4` elements are on the stack, the script MUST fail and terminate immediately.
    * Loop from `i = 0` until `i = n_extra` (inclusive):
        * `d_i` is equal to the `i + 3` from top element of the stack.
        * `m_i` is the SHA256 digest of `d_i`.
    * The message is the concatenation of `m_0` through `m_n_extra`
    * The public key (second from top element), and signature (`4 + n_extra` from top element) are read from the stack.
    * For `OP_CHECKSIGFROMSTACK` the top `n_extra + 4` elements are popped from the stack.
* Otherwise:
    * The public key (top element), message (second to top element), and signature (third from top element) are read from the stack.
    * For `OP_CHECKSIGFROMSTACK` the top three elements are popped from the stack.
* If the public key size is zero, the script MUST fail and terminate immediately.
* If the public key size is 32 bytes, it is considered to be a public key as described in [BIP 340]:
    * If the signature is not the empty vector, the signature is validated against the public key and message according to [BIP 340]. Validation failure in this case immediately terminates script execution with failure.
* If the public key size is not zero, and it is not a [BIP 340] public key; the public key is of an unknown public key type, and no actual signature verification is applied. During script execution of signature opcodes they behave exactly as known public key types except that signature validation is considered to be successful.
* If the script did not fail and terminate before this step, regardless of the public key type:
    * If the signature is the empty vector:
        * For `OP_CHECKSIGFROMSTACKVERIFY`, the script MUST fail and terminate immediately.
        * For `OP_CHECKSIGFROMSTACK`, an empty vector is pushed onto the stack, and execution continues with the next opcode.
    * If the signature is not the empty vector:
        * For tapscript 0xc0, the opcode is counted towards the sigops budget as described in [BIP 341].
        * For legacy and segwit v0, the opcode is counted towards the sigops limit, as described in [BIP 141]
        * For `OP_CHECKSIGFROMSTACKVERIFY`, execution continues without any further changes to the stack.
        * For `OP_CHECKSIGFROMSTACK`, a 1-byte value 0x01 is pushed onto the stack.

## Design Considerations

1. Message hashing: [BIP 340] is compatible with any size of message and does not require it to be a securely hashed input, so the message is not hashed prior to [BIP 340] verification.
2. Verify NOP upgrade: To bring stack signature verification to legacy and segwitv0 bitcoin script, a NOP upgrade path was chosen for `OP_CHECKSIGFROMSTACKVERIFY`. This necessarily means leaving the 3 arguments on the stack when executing `OP_CHECKSIGFROMSTACKVERIFY`. Scripts will need to drop or otherwise manage these stack elements.
3. Add/multisig: No concession is made to `OP_CHECKMULTISIG` or `OP_CHECKSIGADD` semantics with `OP_CHECKSIGFROMSTACK(VERIFY)`. In Tapscript, add semantics can be implemented with 1 additional vByte per key (`OP_TOALTSTACK OP_CHECKSIGFROMSTACK OP_FROMALTSTACK OP_ADD`).
4. Splitting R/S on the stack: Implementing split/separate signatures is left as an exercise for other bitcoin upgrades, such as `OP_CAT`.
5. [BIP 118]-style Taproot internal key: Rather than introducing an additional key type in this change, we suggest implementing OP_INTERNALKEY or separately introducing that key type for all Tapscript signature checking operations in a separate change.
6. Unknown key lengths: The semantics of other signature checking opcodes in their respective script types (legacy, segwit-v0, tapscript-c0) are applied.
7. Vector commitment: We include the ability to validate signatures over a message in multiple parts. This adds some complexity to the specification, but ensures that it can be used in protocols requiring a single signer to commit to multiple items without requiring [OP_CAT] or multiple signatures. For example, the current proof of concept for LN Symmetry requires that update transaction `n` be signed with a hash of update `n+1`'s settlement script to ensure that a later update can reproduce that hash for spending. The current POC places this additional signed data in the Taproot annex, but we consider it more elegant to explicitly require the additional signed data in the update script via `<pubkey> 1 OP_CHECKSIGFROMSTACK`.

## Resource Limits

These opcodes are treated identically to other signature checking opcodes and
count against the various sigops limits and budgets in their respective script
types.

## Motivation

### LN Symmetry

When combined with [BIP 119] (`OP_CHECKTEMPLATEVERIFY`/CTV),
`OP_CHECKSIGFROMSTACK` (CSFS) can be used in Lightning Symmetry channels.
The construction `OP_CHECKTEMPLATEVERIFY <pubkey> OP_CHECKSIGFROMSTACK` with a
spend stack containing the CTV hash and a signature for it is logically
equivalent to `<bip118_pubkey> OP_CHECKSIG` and a signature over
`SIGHASH_ALL|SIGHASH_ANYPREVOUTANYSCRIPT`. The `OP_CHECKSIGFROMSTACK`
construction is 8 vBytes larger.

### Delegation

Using a script like:
`<pubkey> SWAP IF 2 PICK SWAP CSFSV ENDIF CHECKSIG`
either direct verification or delegation can be achieved by the following
unlock stacks: `<sig> 0` or `<dsig> <dpubkey> <sig> 1`

## Reference Implementation

A reference implementation is provided in provided here:

https://github.com/brandonblack/bitcoin/commit/5aae0503ceab93101c459748347a111e4a4852c4

## Backward Compatibility

By constraining the behavior of an OP_SUCCESS opcode and an OP_NOP opcode,
deployment of the BIP can be done in a backwards compatible, soft-fork manner.
If anyone were to rely on the OP_SUCCESS behavior of
`OP_SUCCESS204`, `OP_CHECKSIGFROMSTACK` would invalidate
their spend.

## Deployment

TBD

## Credits

Reference implementation was made with reference to the implementation in
Elements and started by moonsettler.

## Copyright

This document is licensed under the 3-clause BSD license.

[BIP 119]: https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki

[BIP 118]: https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki

[BIP 340]: https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki

[BIP 341]: https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki

[BIP 342]: https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki

[OP_CAT]: https://github.com/EthanHeilman/op_cat_draft/blob/main/cat.mediawiki
